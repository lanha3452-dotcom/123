<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Breakout</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0f172a; /* Slate-900 */
            touch-action: none; /* Prevent scroll on mobile */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
        }
        /* UI Overlay transitions */
        .overlay {
            transition: opacity 0.3s ease;
        }
        .hidden {
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <!-- UI Layer -->
    <div id="ui-layer" class="absolute inset-0 pointer-events-none flex flex-col justify-between p-4 z-10 text-white">
        <!-- Header -->
        <div class="flex justify-between items-start">
            <div>
                <h1 class="text-xl font-bold text-cyan-400 tracking-wider">NEON BREAKOUT</h1>
                <p class="text-xs text-slate-400">SCORE: <span id="score-display" class="text-white font-mono text-lg">0</span></p>
            </div>
            <div class="flex gap-2 pointer-events-auto">
                <button id="btn-pause" class="p-2 rounded-full bg-slate-800/50 hover:bg-slate-700/80 backdrop-blur border border-slate-600 transition">
                    <i class="fas fa-pause text-sm"></i>
                </button>
            </div>
        </div>

        <!-- Lives -->
        <div class="flex justify-center gap-1">
             <div id="lives-display" class="flex gap-1 text-red-500">
                 <i class="fas fa-heart"></i>
                 <i class="fas fa-heart"></i>
                 <i class="fas fa-heart"></i>
             </div>
        </div>
    </div>

    <!-- Start / Game Over Screen -->
    <div id="menu-overlay" class="absolute inset-0 z-20 flex items-center justify-center bg-slate-900/90 backdrop-blur-sm overlay">
        <div class="text-center p-8 border border-cyan-500/30 rounded-2xl bg-slate-800/50 shadow-[0_0_50px_rgba(6,182,212,0.2)]">
            <h2 id="menu-title" class="text-4xl font-black text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500 mb-2">READY?</h2>
            <p id="menu-subtitle" class="text-slate-300 mb-6 text-sm">打破所有磚塊以獲勝</p>
            
            <div class="space-y-3">
                <button id="btn-start" class="w-full px-8 py-3 bg-cyan-600 hover:bg-cyan-500 text-white font-bold rounded-lg shadow-lg shadow-cyan-500/30 transition transform hover:scale-105 active:scale-95">
                    開始遊戲
                </button>
                
                <!-- NEW LLM Feature Button -->
                <button id="btn-gemini-suggest" onclick="window.game.generatePowerUpSuggestion()" class="w-full px-8 py-2 bg-purple-600 hover:bg-purple-500 text-white font-bold rounded-lg transition transform hover:scale-[1.02] active:scale-[0.98] flex items-center justify-center">
                    ✨ 獲取 Level Up 靈感
                </button>

            </div>
            
            <!-- NEW LLM Suggestion Display -->
            <div id="suggestion-output" class="mt-4 text-left p-3 text-sm bg-slate-700/50 rounded-lg hidden">
                <p class="text-purple-300 font-semibold mb-1">Level 靈感：</p>
                <div id="suggestion-text" class="text-slate-200">
                    <!-- Dynamic content will be placed here -->
                </div>
                <div id="loading-indicator" class="text-purple-400 flex items-center justify-center hidden">
                    <i class="fas fa-spinner fa-spin mr-2"></i>正在產生 Level Up 靈感...
                </div>
            </div>

            <p class="mt-4 text-xs text-slate-500">使用滑鼠或手指移動擋板</p>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        // --- Configuration ---
        const CONFIG = {
            paddleColor: '#38bdf8', // Sky-400
            ballColor: '#ffffff',
            brickColors: ['#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6', '#a855f7'], // Rainbow-ish
            bgFade: 0.2, // Trail effect intensity (lower is longer trail)
            particleCount: 10,
            particleDecay: 0.02,
            initialLives: 3
        };

        // --- Classes ---

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                // Random velocity
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                this.dx = Math.cos(angle) * speed;
                this.dy = Math.sin(angle) * speed;
                this.alpha = 1;
                this.size = Math.random() * 3 + 1;
            }

            update() {
                this.x += this.dx;
                this.y += this.dy;
                this.alpha -= CONFIG.particleDecay;
                this.size *= 0.95; // shrink
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class Ball {
            constructor(game) {
                this.game = game;
                this.radius = 6;
                this.reset();
            }

            reset() {
                this.x = this.game.width / 2;
                this.y = this.game.height - 40;
                this.speed = 5;
                // Randomize start angle slightly but mostly up
                const angle = -Math.PI / 2 + (Math.random() * 0.4 - 0.2); 
                this.dx = this.speed * Math.cos(angle);
                this.dy = this.speed * Math.sin(angle);
                this.active = false; // Waiting for player to click/tap
            }

            launch() {
                if (!this.active) {
                    this.active = true;
                    // Ensure consistent starting speed
                    this.dx = 4 * (Math.random() > 0.5 ? 1 : -1);
                    this.dy = -4; 
                }
            }

            update() {
                if (!this.active) {
                    // Stick to paddle
                    this.x = this.game.paddle.x + this.game.paddle.width / 2;
                    this.y = this.game.paddle.y - this.radius - 2;
                    return;
                }

                this.x += this.dx;
                this.y += this.dy;

                // Wall Collisions
                if (this.x + this.radius > this.game.width || this.x - this.radius < 0) {
                    this.dx *= -1;
                    // Push out of wall to prevent sticking
                    if(this.x < 0) this.x = this.radius;
                    if(this.x > this.game.width) this.x = this.game.width - this.radius;
                }

                if (this.y - this.radius < 0) {
                    this.dy *= -1;
                    this.y = this.radius;
                }

                // Floor Collision (Death)
                if (this.y - this.radius > this.game.height) {
                    this.game.loseLife();
                }

                // Paddle Collision
                const p = this.game.paddle;
                if (
                    this.x > p.x &&
                    this.x < p.x + p.width &&
                    this.y + this.radius > p.y &&
                    this.y - this.radius < p.y + p.height
                ) {
                    // Simple reflection isn't fun. Let's vary angle based on hit position.
                    let hitPoint = this.x - (p.x + p.width / 2);
                    // Normalize hit point (-1 to 1)
                    hitPoint = hitPoint / (p.width / 2);
                    
                    // Calculate angle: straight up is -90deg (-PI/2)
                    // We bend it up to 60 degrees either way
                    const angle = hitPoint * (Math.PI / 3); 

                    // Speed up slightly on every paddle hit, capped at max
                    const currentSpeed = Math.sqrt(this.dx*this.dx + this.dy*this.dy);
                    const newSpeed = Math.min(currentSpeed * 1.02, 12);

                    this.dx = newSpeed * Math.sin(angle);
                    this.dy = -newSpeed * Math.cos(angle);
                }
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = CONFIG.ballColor;
                ctx.shadowBlur = 15;
                ctx.shadowColor = CONFIG.ballColor;
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.closePath();
            }
        }

        class Paddle {
            constructor(game) {
                this.game = game;
                this.width = 100;
                this.height = 12;
                this.reset();
            }

            reset() {
                this.x = this.game.width / 2 - this.width / 2;
                this.y = this.game.height - 30;
            }

            update(inputX) {
                // Update position based on input (mouse/touch)
                if (inputX !== null) {
                    this.x = inputX - this.width / 2;
                }

                // Constraints
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > this.game.width) this.x = this.game.width - this.width;
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.roundRect(this.x, this.y, this.width, this.height, 6);
                ctx.fillStyle = CONFIG.paddleColor;
                ctx.shadowBlur = 10;
                ctx.shadowColor = CONFIG.paddleColor;
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.closePath();
            }
        }

        class Brick {
            constructor(x, y, w, h, color) {
                this.x = x;
                this.y = y;
                this.width = w;
                this.height = h;
                this.color = color;
                this.status = 1; // 1 = active, 0 = broken
            }

            draw(ctx) {
                if (this.status === 1) {
                    ctx.beginPath();
                    ctx.rect(this.x, this.y, this.width, this.height);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                    
                    // Inner bevel for 3D look
                    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.closePath();
                }
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                
                // HiDPI fix
                this.dpr = window.devicePixelRatio || 1;
                
                this.resize();
                
                this.paddle = new Paddle(this);
                this.ball = new Ball(this);
                this.bricks = [];
                this.particles = [];
                
                this.score = 0;
                this.lives = CONFIG.initialLives;
                this.state = 'MENU'; // MENU, PLAYING, GAMEOVER, PAUSED
                this.inputX = null;

                this.bindEvents();
                this.createBricks();
            }

            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.canvas.width = this.width * this.dpr;
                this.canvas.height = this.height * this.dpr;
                this.ctx.scale(this.dpr, this.dpr);
                
                // Reposition paddle if game is running
                if (this.paddle) this.paddle.y = this.height - 30;
            }

            createBricks() {
                this.bricks = [];
                const rows = 6;
                const cols = 9;
                const padding = 10;
                const offsetTop = 60;
                const offsetLeft = 20; // Will be calculated to center
                
                // Calculate responsive brick width
                const availableWidth = this.width - (offsetLeft * 2);
                const brickWidth = (availableWidth - (padding * (cols - 1))) / cols;
                const brickHeight = 20;

                for(let c=0; c<cols; c++) {
                    for(let r=0; r<rows; r++) {
                        const brickX = offsetLeft + (c * (brickWidth + padding));
                        const brickY = offsetTop + (r * (brickHeight + padding));
                        const color = CONFIG.brickColors[r % CONFIG.brickColors.length];
                        this.bricks.push(new Brick(brickX, brickY, brickWidth, brickHeight, color));
                    }
                }
            }

            bindEvents() {
                window.addEventListener('resize', () => this.resize());
                
                // Mouse Move
                this.canvas.addEventListener('mousemove', (e) => {
                    this.inputX = e.clientX;
                });

                // Touch Move
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.inputX = e.touches[0].clientX;
                }, { passive: false });

                // Click / Tap to start or launch ball
                const actionHandler = () => {
                    if (this.state === 'PLAYING' && !this.ball.active) {
                        this.ball.launch();
                    }
                };
                
                this.canvas.addEventListener('mousedown', actionHandler);
                this.canvas.addEventListener('touchstart', actionHandler);

                // UI Buttons
                document.getElementById('btn-start').addEventListener('click', () => this.startGame());
                document.getElementById('btn-pause').addEventListener('click', () => this.togglePause());
            }

            spawnParticles(x, y, color) {
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    this.particles.push(new Particle(x, y, color));
                }
            }

            checkBrickCollision() {
                for (let b of this.bricks) {
                    if (b.status === 1) {
                        if (
                            this.ball.x > b.x &&
                            this.ball.x < b.x + b.width &&
                            this.ball.y > b.y &&
                            this.ball.y < b.y + b.height
                        ) {
                            this.ball.dy *= -1;
                            b.status = 0;
                            this.score += 10;
                            this.spawnParticles(b.x + b.width/2, b.y + b.height/2, b.color);
                            document.getElementById('score-display').innerText = this.score;

                            // Check Win
                            if (this.bricks.every(brick => brick.status === 0)) {
                                this.gameOver(true);
                            }
                            return; // Only hit one brick per frame
                        }
                    }
                }
            }

            update() {
                if (this.state !== 'PLAYING') return;

                this.paddle.update(this.inputX);
                this.ball.update();
                this.checkBrickCollision();

                // Update particles
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    this.particles[i].update();
                    if (this.particles[i].alpha <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }

            draw() {
                // Trail effect: clear with transparency instead of full clear
                this.ctx.fillStyle = `rgba(15, 23, 42, ${CONFIG.bgFade})`;
                this.ctx.fillRect(0, 0, this.width, this.height);

                this.bricks.forEach(b => b.draw(this.ctx));
                this.particles.forEach(p => p.draw(this.ctx));
                this.paddle.draw(this.ctx);
                this.ball.draw(this.ctx);
            }

            loop() {
                if(this.state !== 'PAUSED') {
                    this.update();
                    this.draw();
                }
                requestAnimationFrame(() => this.loop());
            }

            loseLife() {
                this.lives--;
                this.updateLivesDisplay();
                
                if (this.lives > 0) {
                    this.ball.active = false;
                    this.ball.reset();
                } else {
                    this.gameOver(false);
                }
            }

            updateLivesDisplay() {
                const container = document.getElementById('lives-display');
                container.innerHTML = '';
                for(let i=0; i<this.lives; i++) {
                    container.innerHTML += '<i class="fas fa-heart"></i>';
                }
                for(let i=0; i<(CONFIG.initialLives - this.lives); i++) {
                     container.innerHTML += '<i class="far fa-heart opacity-50"></i>';
                }
            }

            startGame() {
                this.score = 0;
                this.lives = CONFIG.initialLives;
                this.state = 'PLAYING';
                document.getElementById('score-display').innerText = '0';
                this.updateLivesDisplay();
                document.getElementById('menu-overlay').classList.add('hidden');
                
                this.createBricks();
                this.ball.reset();
                this.paddle.reset();
                
                // Clear any previous LLM suggestion when starting
                document.getElementById('suggestion-output').classList.add('hidden');
                document.getElementById('suggestion-text').innerHTML = '';
            }

            togglePause() {
                if (this.state === 'PLAYING') {
                    this.state = 'PAUSED';
                    document.getElementById('btn-pause').innerHTML = '<i class="fas fa-play text-sm"></i>';
                } else if (this.state === 'PAUSED') {
                    this.state = 'PLAYING';
                    document.getElementById('btn-pause').innerHTML = '<i class="fas fa-pause text-sm"></i>';
                }
            }

            gameOver(win) {
                this.state = 'GAMEOVER';
                const menu = document.getElementById('menu-overlay');
                const title = document.getElementById('menu-title');
                const sub = document.getElementById('menu-subtitle');
                const btn = document.getElementById('btn-start');

                menu.classList.remove('hidden');
                
                if (win) {
                    title.innerText = "VICTORY!";
                    title.classList.replace('from-cyan-400', 'from-green-400');
                    title.classList.replace('to-blue-500', 'to-emerald-500');
                    sub.innerText = `Final Score: ${this.score}`;
                } else {
                    title.innerText = "GAME OVER";
                    title.classList.replace('from-green-400', 'from-cyan-400');
                    title.classList.replace('to-emerald-500', 'to-blue-500');
                    sub.innerText = "再試一次？";
                }
                
                btn.innerText = "重新開始";
            }
            
            // --- Gemini API Integration: Power-Up Suggestion ---
            async generatePowerUpSuggestion() {
                const outputDiv = document.getElementById('suggestion-output');
                const textDiv = document.getElementById('suggestion-text');
                const loading = document.getElementById('loading-indicator');
                
                outputDiv.classList.remove('hidden');
                textDiv.innerHTML = '';
                loading.classList.remove('hidden');

                const userPrompt = `The player just ended a level in a neon-themed breakout game. The final score was ${this.score}. Generate a brief, compelling theme for the *next* level and a suggestion for a unique, cool-sounding power-up. Provide only the name of the power-up and a short description of its effect. The power-up should be suitable for a fast-paced game.`;
                const systemPrompt = "You are a creative game designer. Respond strictly with the requested JSON schema, using exciting and neon-themed language.";
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

                const payload = {
                    contents: [{ parts: [{ text: userPrompt }] }],
                    systemInstruction: { parts: [{ text: systemPrompt }] },
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "levelTheme": { "type": "STRING", "description": "A dark, intense theme for the next level." },
                                "powerUpName": { "type": "STRING", "description": "A concise name for a new power-up (e.g., 'Triple Ball')." },
                                "powerUpDescription": { "type": "STRING", "description": "A short, exciting description of the power-up effect." }
                            },
                            required: ["levelTheme", "powerUpName", "powerUpDescription"]
                        }
                    }
                };

                // Exponential backoff retry logic
                const maxRetries = 3;
                let response = null;
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        if (response.ok) break;
                    } catch (error) {
                        // Network error, try again after delay
                        await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
                    }
                }
                
                loading.classList.add('hidden');

                if (!response || !response.ok) {
                    textDiv.innerHTML = '<span class="text-red-400">無法獲取靈感，請稍後再試。</span>';
                    return;
                }

                try {
                    const result = await response.json();
                    const jsonString = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!jsonString) throw new Error("Invalid response structure.");

                    const parsedJson = JSON.parse(jsonString);
                    
                    const htmlContent = `
                        <p class="mb-2"><strong>主題:</strong> ${parsedJson.levelTheme}</p>
                        <p class="mb-2 text-purple-400"><strong>Power-Up:</strong> ${parsedJson.powerUpName}</p>
                        <p class="text-slate-400 text-xs"><em>效果:</em> ${parsedJson.powerUpDescription}</p>
                    `;
                    textDiv.innerHTML = htmlContent;

                } catch (error) {
                    console.error("Gemini Response Error:", error);
                    textDiv.innerHTML = '<span class="text-red-400">靈感解析錯誤，請檢查主控台。</span>';
                }
            }
            // --- End Gemini API Integration ---
        }

        // Start the game
        window.onload = () => {
            const game = new Game();
            window.game = game; // Expose Game instance globally for button click
            game.loop();
        };

    </script>
</body>
</html>